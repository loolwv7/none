\section{About sed ...}
In sed and awk, each instruction has two parts: a pattern and a procedure. The pattern is a regular
expression delimited with slashes (/). A procedure specifies one or more actions to be performed.

In summary, use sed:
    1. To automate editing actions to be performed on one or more files.
        2. To simplify the task of performing the same edits on multiple files.
	3. To write conversion programs.

  Some of the things awk allows you to do are:
     q  View a text file as a textual database made up of records and fields.
        q  Use variables to manipulate the database.
	   q  Use arithmetic and string operators.
	      q  Use common programming constructs such as loops and conditionals.
	         q  Generate formatted reports.
		    q  Define functions.
		       q  Execute UNIX commands from a script.
		          q  Process the result of UNIX commands.
			     q  Process command-line arguments more gracefully.
			        q  Work more easily with multiple input streams.


Of course, must try your hand at writing scripts yourself.


If you are starting out to learn sed and awk, you can benefit from looking at how much they have in
common.
     q They are invoked using similar syntax.
     q They are both stream-oriented, reading input from text files one line at a time and directing the result to standard output.
     q They use regular expressions for pattern matching.
     q They allow the user to specify instructions in a script.



    One option common to both sed and awk is the -f option that allows you to specify the name of a script
    file. As a script grows in size, it is convenient to place it in a file. Thus, you might invoke sed as follows:



    In sed and awk, each instruction has two parts: a pattern and a procedure. The pattern is a regular
    expression delimited with slashes (/). A procedure specifies one or more actions to be performed.
    As each line of input is read, the program reads the first instruction in the script and checks the pattern
    against the current line. If there is no match, the procedure is ignored and the next instruction is read. If
    there is a match, then the action or actions specified in the procedure are followed. All of the
    instructions are read, not just the first instruction that matches the input line.

   
    The contents of a procedure are very different in sed and awk. In sed, the procedure consists of editing
    commands like those used in the line editor. Most commands consist of a single letter.
    In awk, the procedure consists of programming statements and functions. A procedure must be
    surrounded by braces.



          g/regular/s/regular/complex/g
	  Now the substitution is made everywhere - all occurrences on all lines.
    NOTE: Note the different meanings of "g." The "g" at the beginning is the global
 command that means make the changes on all lines matched by the address. The "g" at the
 end is a flag that means change each occurrence on a line, not just the first.


 Sed was created as a special-purpose editor that was meant to execute scripts exclusively; unlike ed, it
 cannot be used interactively. Sed differs from ed primarily in that it is stream-oriented. By default, all o
 the input to sed passes through and goes to standard output. The input file itself is not changed. If you
 actually do want to alter the input file, you typically use the shell mechanism for output redirection, and
 when you are satisfied with the edits you've made, replace the original file with the modified version.


 ed is not stream-oriented and changes are made to the file itself. An ed script must contain commands
 to save the file and quit the editor. It produces no output to the screen, except what may be generated by
 a specific command.

 The stream orientation of sed has a major impact on how addressing is applied. In ed, a command
 without an address affects only the current line. Sed goes through the file, a line at a time, such that each
 line becomes the current line, and the commands are applied to it. The result is that sed applies a
 command without an address to every line in the file.

 NOTE:Awk was developed as a programmable editor that, like sed, is stream-oriented and interprets a script of
 editing commands. Where awk departs from sed is in discarding the line-editor command set. It offers in

NOTE:One of the most distinctive features of awk is that it {\color{blue}parses}, or breaks up, each input line and makes
individual words available for processing with a script. (An editor such as vi also recognizes words,
    allowing you to move word by word, or make a word the object of an action, but these features can only
    be used interactively.)

{\color{Blue} Parses,technical to describe the grammar of a word when it is in a particular sentence, or the grammar of the whole sentence}

Identifying awk as a programming language scares some people away from it. If you are one of them,consider awk a different approach to problem solving, one in which you have a lot more control over what you want the computer to do.

NOTE:The key to all of these operations is that the data has some kind of structure. Let us illustrate this with
the analogy of a bureau. A bureau consists of multiple drawers, and each drawer has a certain set of
contents: socks in one drawer, underwear in another, and sweaters in a third drawer. Sometimes drawers
have compartments allowing different kinds of things to be stored together. These are all structures that
determine where things go - when you are sorting the laundry - and where things can be found - when
you are getting dressed. Awk allows you to use the structure of a text file in writing the procedures for
putting things in and taking things out.





	      
Sed also has the ability to be used as an editing filter. In other words, you could process an input file and
send the output to another program. For instance, you could use sed to analyze a plain text file and insert
troff macros before directing the output to troff for formatting. It allows you to make edits on the
fly, perhaps ones that are temporary.


In summary, use sed:
1. To automate editing actions to be performed on one or more files.
2. To simplify the task of performing the same edits on multiple files.
3. To write conversion programs.



1. Separate instructions with a semicolon.
{\color{blue}  sed 's/ MA/, Massachusetts/; s/ PA/, Pennsylvania/' list}
2. Precede each instruction by -e.
{\color{blue} sed -e 's/ MA/, Massachusetts/' -e 's/ PA/, Pennsylvania/' list}


3. Use the multiline entry capability of the Bourne shell.[1] Press RETURN after entering a single quote and a secondary prompt (>) will be displayed for multiline input.
[1] These days there are many shells that are compatible with the Bourne shell, and
work as described here: ksh, bash, pdksh, and zsh, to name a few.
      $ sed '
       > s/ MA/, Massachusetts/
       > s/ PA/, Pennsylvania/
       > s/ CA/, California/' list

In the example above, changes were made to five lines and, of course, all lines were displayed.Remember that nothing has changed in the input file.

$ sed -e 's/MA/Massachusetts' list
NOTE sed: command garbled: s/MA/Massachusetts

The -e option is necessary only when you supply more than one instruction on the command line. It tells
sed to interpret the next argument as an instruction. When there is a single instruction, sed is able to
make that determination on its own. Let's look at some examples.



It is not practical to enter longer editing scripts on the command line. That is why it is usually best to
create a script file that contains the editing instructions. The editing script is simply a list of sed
commands that are executed in the order in which they appear. This form, using the -f option, requires
that you specify the name of the script file on the command line.
{\LARGE sed -f scriptfile file}


Once again, the result is ephemeral, displayed on the screen. No change is made to the input file.If a sed script can be used again, you should rename the script and save it. Scripts of proven value can be maintained in a personal or system-wide library.

\subsection{Save file}
       $ sed -f sedscr list > newlist

{\color{red}Do not redirect the output to the file you are editing or you will clobber it.} (The ">" redirection operator truncates the file before the shell does anything else.) If you want the output file to replace the input file, you can do that as a separate step, using the mv command. But first make very sure your editing script as worked properly!


The default operation of sed is to output every input line. The -n option suppresses the automatic output.When specifying this option, each instruction intended to produce output must contain a print command,
     p. Look at the following example.

           $ sed -n -e 's/MA/Massachusetts/p' list


NOTE:You can build up a script by combining both the -e and -f options on the command line

\section{Awk About}

While awk instructions have the same structure as sed, consisting of pattern and procedure sections, the procedures themselves are quite different. Here is where awk looks less like an editor and more like a programming language. There are statements and functions instead of one- or two-character command sequences. For instance, you use the print statement to print the value of an expression or to print the contents of the current input line.


Compareing grep,sed AND awk followed:

$ grep 'MA' LIST
$ sed -n '/MA/p' LIST
$ awk '/MA/' LIST


awk '/MA/ { print $1 }' list
NOTE: It helps to understand the above instruction if we try to read it aloud: Print the first word of each line containing the string "MA". We can say "word" because by default awk separates the input into fields using either spaces or tabs as the field separator.

In the next example, we use the -F option to change the field separator to a comma. This allows us to retrieve any of three fields: the full name, the street address, or the city and state.

$ awk -F, '{ print $1 }' LIST
$ awk -F, '/MA/ { print $1 }' LIST 


In the next example, we print each field on its own line. Multiple commands are separated by semicolons.

$ awk -F, '{ print $1; print $2; print $3 }' list

In UNIX, pipes can be used to pass the output from one program as input to the next program. Let's look
at a few examples that combine sed and awk to produce a report. The sed script that replaced the postal
abbreviation of a state with its full name is general enough that it might be used again as a script file
named nameState:

$ sed -f nameState list | awk -F, '{ print $4 }'

What we are doing here could be done completely in sed, but probably with more difficulty and less generality. Also, since awk allows you to replace the string you match, you could achieve this result entirely with an awk script.

While the result of this program is not very useful, it could be passed to sort | uniq -c, which would sort the states into an alphabetical list with a count of the number of occurrences of each state.

#!/bin/sh
awk -F, '{
           print $4 ", " $0
	              }' $* |
sort |
awk -F, '
$1 == LastState {
         print "\t" $2
}
$1 != LastState {
         LastState = $1
	  print $1
}'


This shell script has three parts. The program invokes awk to produce input for the sort program and then invokes awk again to test the sorted input and determine if the name of the state in the current record is the same as in the previous record. Let's see the script in action:

$ sed -f nameState list | byState

There are a few significant things here, including assigning a variable, testing the first field of each input line to see if it contains a variable string, and printing a tab to align the output data. Note that we don't have to assign to a variable before using it (because awk variables are initialized to the empty string).

This is a small script, but you'll see the same kind of routine used to compare index entries in a much larger indexing program in Chapter 12, Full-Featured Applications. However, for now, don't worry too much about understanding what each statement is doing. Our point here is to give you an overview of what sed and awk can do.


\subsection{Error}

Each implementation of awk gives you different error messages when it encounters problems in your program.

\section{Regular Expression Syntax}

When a young child is struggling to understand the meaning of an idiomatic expression, such as "Someone let the cat out of the bag," you might help by explaining that it's an expression, and doesn't literally mean what it says.

NOTE:An expression, even in computer terminology, is not something to be interpreted literally. It is something that needs to be evaluated. An expression describes a result.

While regular expressions are a basic part of UNIX, not everyone has a complete understanding of the syntax. In fact, it can be quite confusing to look at an expression such as:  * ^$ .*

sequence of characters can't be emphasized enough. (Novice users are inclined to think in higher-level units such as words, and not individual characters.) Regular expressions are case-sensitive; "A" does not match "a".[1]
        [1] Some other programs that use regular expressions offer the option of having them be case-insensitive, but sed and awk do not.


A regular expression is not limited to literal characters. There is, for instance, a metacharacter - the dot
(.) - that can be used as a "wildcard" to match any single character. You can think of this wildcard as analogous to a blank tile in Scrabble where it means any letter. Thus, we can specify the regular expression "A.E" and it will match "ACE," "ABE", and "ALE". It will match any character in the position following "A".


NOTE:The metacharacter *, the asterisk, is used to match zero or more occurrences of the preceding regular expression, which typically is a single character. You may be familiar with * as a shell metacharacter,
  where it means "zero or more characters." But that meaning is very different from * in a regular  expression. By itself, the asterisk metacharacter does not match anything; it modifies what goes before  it. The regular expression .* matches any number of characters, whereas in the shell, * has that  meaning. (For instance, in the shell, ls * will list all the files in the current directory.) The regular  expression "A.*E" matches any string that matches "A.E" but it will also match any number of  characters between "A" and "E": "AIRPLANE," "A FINE," "AFFABLE," or "A LONG WAY HOME,"
NOTE:  for example. Note that "any number of characters" can even be zero!


If you understand the difference between "." and "*" in regular expressions, you already know about the two basic types of metacharacters: those that can be evaluated to a single character, and those that modify how preceding characters are evaluated.

A regular expression is made up of these same elements. Any character, except the metacharacters in Table 3.1, is interpreted as a literal that matches only itself.



[...] Matches any one of the class of characters enclosed between the brackets. A circumflex (^)
        as first character inside brackets reverses the match to all characters except newline and those listed in the class. In awk, newline will also match. A hyphen (-) is used to indicate a range of characters. The close bracket (]) as the first character in class is a member of the class. All other metacharacters lose their meaning when specified as members of a class.

Metacharacters have a special meaning in regular expressions, much the same way as + and * have special meaning in arithmetic expressions. Several of the metacharacters (+ ? () |) are available only as part of the extended set used by programs such as egrep and awk. We will look at what each metacharacter does in upcoming sections, beginning with the backslash.

NOTE: The wildcard metacharacter, or dot (.), might be considered equivalent to a variable. A variable represents any value in an arithmetic expression. In a regular expression, a dot (.) is a wildcard that represents any character except the newline. (In awk, dot can even match an embedded newline character.)

  Searching for the string "Chapter" as opposed to "Chapter." would have matched all of the same lines.
  However, there is one case that would be different - if "Chapter" appeared at the end of a line. The wildcard does not match the newline, so "Chapter." would not match that line, while the fixed-string pattern would match the line.



\subsection{Writting Regular Expressions

 You could say that whoever wrote the first expression did not fully understand the scope of the problem
  and thus did not describe it well. It is important to know just how detailed a description must be. If you
 ask someone to bring you a book, and there are multiple books in view, you need to describe more
specifically the book that you want (or be content with an indeterminate selection process).

 The process of writing a regular expression involves three steps:

   1. Knowing what it is you want to match and how it might appear in the text.
   2. Writing a pattern to describe what you want to match.
   3. Testing the pattern to see what it matches.

This process is virtually the same kind of process that a programmer follows to develop a program. Step 1 might be considered the specification, which should reflect an understanding of the problem to be solved as well as how to solve it. Step 2 is analogous to the actual coding of the program, and Step 3
involves running the program and testing it against the specification. Steps 2 and 3 form a loop that is
repeated until the program works satisfactorily.


\ldot will greatly improve your understanding of regular expressions. You might consider evaluating the results of a pattern matching-operation as follows:

Hits
       The lines that I wanted to match.
Misses
       The lines that I didn't want to match.
Omissions
       The lines that I didn't match but wanted to match.
False alarms
       The lines that I matched but didn't want to match.


Character classes are useful for dealing with uppercase and lowercase letters, for instance. If "what" might appear with either an initial capital letter or a lowercase letter, you can specify:
       [Ww]hat

\ Escapes any special character (awk only)
- Indicates a range when not in the first or last position.
^ Indicates a reverse match only when in the first position.
NOTE:The backslash is special only in awk, making it possible to write "[a\]1]" for a character class that will match an a, a right bracket, or a 1.



grep '^[!?;:,"]' CH0[234]/* | less
grep '[!?;:,"]$' CH0[234]/* | less


.[!?;:,".]  .

This expression matches "any character followed by an exclamation mark or question mark or semicolon or colon or comma or quotation mark or period and then followed by two spaces and any character." It could be used to find places where two spaces had been left between the end of a sentence and the
beginning of the next sentence, when this occurs on one line. Notice that there are three dots in this
expression. The first and last dots are wildcard metacharacters, but the second dot is interpreted literally.

The hyphen character (-) allows you to specify a range of characters. For instance,

    [A-Z],[1-9],

    [cC]hapter [1-9]
It matches the string "chapter" or "Chapter" followed by a space and then followed by any single-digit number from 1 to 9. Each of the following lines match the pattern:


    [0-9a-z?,.;:'"]
  This expression will match "any single character that is numeric, lowercase alphabetic, or a question mark, comma, period, semicolon, colon, single quote, or quotation mark." Remember that each characte  class matches a single character. If you specify multiple classes, you are describing multiple consecutive  characters such as:
              [a-zA-Z][.?!]

 The hyphen loses its special meaning within a class if it is the first or last character. Therefore, to match arithmetic operators, we put the
hyphen (-) first in the following example:
        [-+*/]

Trying to match dates with a regular expression is an interesting problem. Here are two possible formats:
       MM-DD-YY
       MM/DD/YY
The following regular expression indicates the possible range of values for each character position:
       [0-1][0-9][-/][0-3][0-9][-/][0-9][0-9]
NOTE that the expression matches dates that mix their delimiters, as well as impossible dates like "15/32/78."



Look at the following regular expression:
       \.DS "[^1]"
    This expression matches the string ".DS" followed by a space, a quote followed by any character other than the number "1," followed by a quote.

    \subsection{POSIX character class additions}

All three of these constructs must appear inside the square brackets of a bracket expression. For example [[:alpha:]!] matches any single alphabetic character or the exclamation point, [[.ch.]] matches the  collating element ch, but does not match just the letter c or the letter h. In a French locale, [[=e=]] might  match any of e, è, or é. Classes and matching characters are shown in Table 3.3.

Class     Matching Characters
[:alnum:] Printable characters (includes whitespace)
[:alpha:] Alphabetic characters
[:blank:] Space and tab characters
[:cntrl:] Control characters
[:digit:] Numeric characters
[:graph:] Printable and visible (non-space) characters
[:lower:]  Lowercase characters
[:print:]  Alphanumeric characters
[:punct:]  Punctuation characters
[:space:]  Whitespace characters
[:upper:]  Uppercase characters
[:xdigit:] Hexadecimal digits

These features are slowly making their way into commercial versions of sed and awk, as vendors fully implement the POSIX standard. GNU awk and GNU sed support the character class notation, but not the other two bracket notations. Check your local system documentation to see if they are available to you.

You could print all lines with these marks by specifying:
      $ grep '<.*>' sample
    
      $ grep "can.t" */*
			 Will match "can't","can think"\ldot

      
  I can do it
  I cannot do it
  I can not do it
  I can't do it
  I cant do it

If we wanted to match each form of the negative statement, but not the positive statement, the following regular expression would do it:
{\color{blue} can[ no']*t \newline 
	 grep "can[ no']*t" sample \\
	 grep "can[ no']t" sample :Would same as followed one, \\
	 grep "can*'t" sample :Would just match "I can't do it" \\
	 grep "can*t" sample  :Would just match "I cant do it" \\
	 egrep "can?t" sample 

	 NOTE:Don't confuse the ? in a regular expression with the ? wildcard in the shell. The shell's ? represents a single character, equivalent to . in a regular expression.
} 
There are four hits and one miss, the positive statement. Notice that had the regular expression tried to match any number of characters between the string "can" and "t," as in the following example:
       can.*t
it would have matched all lines.


The plus sign (+) matches one or more occurrences of the preceding regular expression.
The plus sign metacharacter can be thought of as "at least one" of the preceding character. In fact, it better corresponds to how many people think * works.

As you have probably figured out, it is sometimes difficult to match a complete word. For instance, if we wanted to match the pattern "book," our search would hit lines containing the word "book" and "books" but also the words "bookish," "handbook," and "booky." The obvious thing to do to limit the matching is
to surround "book" with spaces.

 $ grep " book " sample

 However, this expression would only match the word "book"; it would miss the plural "books". To match either the singular or plural word, you could use the asterisk metacharacter:

  $ grep " books* " sample

  This will match "book" or "books". However, it will not match "book" if it is followed by a period, a comma, a question mark, or a quotation mark.

  $ grep " book.* " sample
  This expression matches the string "book" followed by "any number of characters or none followed by a  space." Here are a few lines that would match:
  Furthermore, since the question mark metacharacter is not available with sed, we would have to resort to character classes anyway, as you'll see later on.

(The '	' represents a literal tab character, which is normally invisible.) Without the ^ metacharacter, this expression would print any line containing a tab.

You can use both positional metacharacters together to match blank lines:
$ grep "^$" sample

You might use this pattern to count the number of blank lines in a file using the count option, -c, to
      $ grep -c '^$' ch04
      $ grep -c -v '^$' ch04 (-v Opposite)

This regular expression is useful if you want to delete blank lines using sed. The following regular
expression can be used to match a blank line even if it contains spaces:
     $ grep  "^ *$" example

NOTE:
{\color{purple}In sed (and grep), "^" and "$" are only special when they occur at the beginning or end of a regular expression, respectively. Thus "^abc" means "match the letters a, b, and c only at the beginning of the line," while "ab^c" means "match a, b, a literal ^, and then c, anywhere on the line." The same is true for the "$."

In awk, it's different; "^" and "$" are always special, even though it then becomes possible to write regular expressions that don't match anything. Suffice it to say that in awk, when you want to match either a literal "^" or "$," you should always escape it with a backslash, no matter what its position in the
regular expression.}


Later, when we look at sed, you'll learn how to match patterns over multiple lines and you'll see a shell script incorporating sed that makes this capability available in a general way.

\{ and \} are available in grep and sed.[8] POSIX egrep and POSIX awk use { and }. In any case, the braces enclose one or two arguments.

For example, the following expression will match "1001," "10001," and "100001" but not "101" or "1000001":

$ grep "10\{2,4\}1" sample
$ sed -ne '/10\{2,4\}1/p' sample
Both do the same result.
  $ grep "[0-9]\{3\}-[0-9]\{4\}" phonenumber

  If you are using pre-POSIX awk, where you do not have braces available, you can simply repeat the character classes the appropriate number of times:
         [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]

$ egrep "Lab(oratorie)?s" mail.list

Bell Laboratories, Lucent Technologies
Bell Labs

You can use parentheses with a vertical bar to group alternative operations. In the following example, we use it to specify a match of the singular or plural of the word "company."
  $ awk  "/compan(y|ies)/" sample
  $ egrep  "compan(y|ies)" sample

  It is important to note that applying a quantifier to a parenthesized group of characters can't be done in most versions of sed and grep, but is available in all versions of egrep and awk.


  The following test file contains numerous occurrences of "book." We've added a notation, which is not  part of the file, to indicate whether the input line should be a "hit" (>) and included in the output or a "miss" (<). We've tried to include as many different examples as possible.

$ grep ' book.* ' bookwordsAnother

As we search for occurrences of the word "book," there are 13 lines that should be matched and 7 lines that should not be matched. First, let's run the previous regular expression on the sample file and check
the results.
$ grep ' book.* ' bookwords

t only prints 8 of the 13 lines that we want to match and it prints 2 of the lines that we don't want tomatch. The expression matches lines containing the words "booky" and "bookish." It ignores "book" atthe beginning of a line and at the end of a line. It ignores "book" when there are certain punctuation
marks involved.

To restrict the search even more, we must use character classes. Generally, the list of characters thatmight end a word are punctuation marks, such as:
    ? . , ! ; : '

In addition, quotation marks, parentheses, braces, and brackets might surround a word or open or close with a word:

Thus, you would have two different character classes: before and after the word. Remember that all we have to do is list the members of the class inside square brackets. 
Before the word, we now have:
         ["[{(]
and after the word:
         []})"?!.,;:'s]

$ grep " [\"[{(]*book[]})\"?\!.,;:'s]* " bookwords

We eliminated the lines that we don't want but there are four lines that we're not getting. Let's examine the four lines:
        book at the beginning of a line or
        at the end of a line book
       "book of the year award"
        A GREAT book!
All of these are problems caused by the string appearing at the beginning or end of a line. Because there is no space at the beginning or end of a line, the pattern is not matched. We can use the positional metacharacters, ^ and $. Since we want to match either a space or beginning or end of a line, we can use egrep and specify the "or" metacharacter along with parentheses for grouping. For instance, to match either the beginning of a line or a space, you could write the expression:

Here's the revised regular expression:
       (^| )["[{(]*book[]})"?\!.,;:'s]*( |$)
 Now let's see how it works:
     $ grep ' book.* ' bookwords
     $ egrep "(^| )[\"[{(]*book[]})\"?\!.,;:'s]*( |$)" bookwords
     This is certainly a complex regular expression; however, it can be broken down into parts. Thisexpression may not match every single instance, but it can be easily adapted to handle other occurrences that you may find.


$ grep "A*Z" sample

This matches "zero or more occurrences of A followed by Z." It will produce the same result as simply specifying "Z". The letter "A" could be there or not; in fact, the letter "Z" is the only character matched.

$ grep "A.*Z" sample

NOTE:
".*" can be interpreted as "zero or more occurrences of any character," which means that "any number ofcharacters" can be found, including none at all. The entire expression can be evaluated as "an Afollowed by any number of characters followed by a Z." 


This can cause problems if what you want is to match the shortest extent possible.


       "[^"]*"
  It matches "a quote followed by any number of characters that do not match a quote followed by a quote":
  $ gres '"[^"]*"' '00' sample
  $ grep '"[^"]*"' bookwords

  Now let's look at a few lines with a dot character (.) used as a leader between two columns of numbers:
        1........5
        5........10
        10.......20
        100......200
    [0-9][0-9]*\.\.*[0-9][0-9]*
 This expression might unexpectedly match the line:

 $ sed 's/\([0-9][0-9]*\)\.\{5,\}\([0-9][0-9]*\)/\1-\2/'
 Will do it right!!!

 A similar expression can be written to match one or more leading tabs or tabs between columns of data.
 You could change the order of columns as well as replacing the tab with another delimiter. You should experiment on your own by making simple and complex replacements, using sed or gres.

NOTE: Table 3.4 lists interesting examples of regular expressions, many of which have been described in this chapter.

Postal Abbreviation for State     [A-Z][A-Z]
City, State                    ^.*, [A-Z][A-Z]
City, State, Zip (POSIX egrep) ^.*, [A-Z][A-Z] [0-9]{5}(-[0-9]{4})?
Month, Day, Year               [A-Z][a-z]\{3,9\} [0-9]\{1,2\}, [0-9]\{4\}
U.S. Social Security Number    [0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}
North-American Local Telephone [0-9]\{3\}-[0-9]\{4\}
Formatted Dollar Amounts       \$[ 0-9]*\.[0-9][0-9]
troff In-line Font Requests    \\f[(BIRP]C*[BW]*
troff Requests                 ^\.[a-z]\{2\}
troff Macros                   ^\.[A-Z12].
troff Macro with arguments     ^\.[A-Z12]. ".*"
HTML In-line Codes             <[^>]*>
Ventura Publisher Style Codes  ^@.* = .*
Match blank lines              ^$
Match entire line              ^.*$
Match one or more spaces        "    *"








\section{Writting Sed Script}

This requires using sed in a controlled, methodical way. In writing a script, you should follow these
steps:
   1. Think through what you want to do before you do it.
   2. Describe, unambiguously, a procedure to do it.
   3. Test the procedure repeatedly before committing to any final changes.

With practice, you can come to rely upon your sed scripts working just as you want them to. (There is    something analogous in the management of one's own time, learning to trust that certain tasks can be  delegated to others. You begin testing people on small tasks, and if they succeed, you give them larger  tasks.)

 All editing commands in a script are applied in order to each line of input.

 Commands are applied to all lines (globally) unless line addressing restricts the lines affected by  editing commands.

 The original input file is unchanged; the editing commands modify a copy of original input line and the copy is sent to standard output.



A sed command can specify zero, one, or two addresses. An address can be a regular expression describing a pattern, a line number, or a line addressing symbol.

If no address is specified, then the command is applied to each line.

If there is only one address, the command is applied to any line matching the address.

If two comma-separated addresses are specified, the command is performed on the first line matching the first address and all succeeding lines up to and including a line matching the second address.

If an address is followed by an exclamation mark (!), the command is applied to all lines that do not match the address.


       1,/^$/d
       This example deletes from the first line up to the first blank line, which, for instance, will delete a mailer header from an Internet mail message that you have saved in a file.
       You can think of the first address as enabling the action and the second address as disabling it. Sed has  no way of looking ahead to determine if the second match will be made. The action will be applied to  lines once the first match is made. The command will be applied to all subsequent lines until the second
match is made. In the previous example, if the file did not contain a blank line, then all lines would be  deleted.
       An exclamation mark (!) following an address reverses the sense of the match. For instance, the following script deletes all lines except those inside tbl input:
              /^\.TS/,/^\.TE/!d

NOTE:
The redirection symbol ">" directs the output from sed to the file newfile. Don't redirect the output from
the command back to the input file or you will overwrite the input file. This will happen before sed even
gets a chance to process the file, effectively destroying your data.


NOTE:
If you find that your script did not produce the results you expected, remember that the easiest "fix" is usually to perfect the editing script and run it again on the original input file. Don't write a new script to "undo" or improve upon changes made in the temporary file.

However, runsed does not protect you from imperfect editing scripts. You should use testsed first to verify your changes before actually making them permanent with runsed.

The $ symbol should not be confused with the $ used in regular expressions, which means the end of the line.



It is pretty obvious which lines have changed. (It is frequently helpful to cut out a portion of a file to use for testing. It works best if the portion is small enough to fit on the screen yet is large enough to include    different examples of what you want to change. 

    The next edit attempts to deal with the extra spaces added to justify each line. We can write a substitut command to match any string of consecutive spaces and replace it with a single space.
          s/       */ /g

It works as advertised, reducing two or more spaces to one. On closer inspection, though, you might notice that the script removes a sequence of two spaces following a period, a place where they might belong.

s/\. */. /g


Before leaving this script, it is instructive to point out that although the script was written to process a specific file, each of the commands in the script is one that you might expect to use again, even if you don't use the entire script again. In other words, you may well write other scripts that delete blank lines
or check for two spaces following a period. Recognizing how commands can be reused in other situations reduces the time it takes to develop and test new scripts. It's like a singer learning a song and adding it to his or her repetoire.


NOTE:
Such a script can be a tremendous time-saver, but it can also be an opportunity to make big-time mistakes. What sometimes happens is that a person writes the script, tests it on one or two out of the hundreds of files and concludes from that test that the script works fine. While it may not be practical to test each file, it is important that the test files you do choose be both representative and exceptional. Remember that text is extremely variable and you cannot typically trust that what is true for a particular occurrence is true for all occurrences.


Using grep to examine large amounts of input can be very helpful. For instance, if you wanted to determine how "core system diskettes" appears in the documents, you could grep for it everywhere and pore over the listing. To be thorough, you should also grep for "core," "core system," "system diskettes," and "diskettes" to look for occurrences split over multiple lines. (You could also use the
phrase script in Chapter 6 to look for occurrences of multiple words over consecutive lines.) Examining the input is the best way to know what your script must do!!

In some ways, writing a script is like devising a hypothesis, given a certain set of facts. You try to prove the validity of the hypothesis by increasing the amount of data that you test it against. If you are going to be running a script on multiple files, use testsed to run the script on several dozen files after you've tested it on a smaller sample. Then compare the temporary files to the originals to see if your assumptions were correct. The script might be off slightly and you can revise it. The more time you spend testing, which is actually rather interesting work, the less chance you will spend your time unraveling problems caused by a botched script.

#! /bin/sh
# getmac -- print mm macro definition for $1
sed -n "/^\.de$1/,/^\.\.$/p" /usr/lib/macros/mmt


        /---/!s/--/\\(em/g
	    It may take a moment to penetrate this syntax. What's different is that we use a pattern address to restrict
	    the lines that are affected by the substitute command, and we use ! to reverse the sense of the pattern
	    match. It says, simply, "If you find a line containing three consecutive hyphens, don't apply the edit." On
	    all other lines, the substitute command will be applied.

You can modify this script to search for almost any kind of coded format. For instance, here's a rough version for a LaTeX file:
       sed -n '
       s/[{}]//g
       s/\\section/ A. /p
       s/\\subsection/ B.              /p' $*

Perhaps there are cases in which we don't want this substitute command to be applied. What if someone
is using hyphens to draw a horizontal line? We can refine this command to exclude lines containing
three or more consecutive hyphens. To do this, we use the ! address modifier:
        /---/!s/--/\\(em/g

It may take a moment to penetrate this syntax. What's different is that we use a pattern address to restrict the lines that are affected by the substitute command, and we use ! to reverse the sense of the pattern match. It says, simply, "If you find a line containing three consecutive hyphens, don't apply the edit." On all other lines, the substitute command will be applied.




Note that without the numeric flag, the substitute command would replace only the first tab

s/(tab) />/2

We can use a similar technique to match parts of a line and swap them. For instance, let's say there are
two parts of a line separated by a colon. We can match each part, putting them within escaped
parentheses and swapping them in the replacement.

$ cat test1
first:second
one:two
$ sed 's/\(.*\):\(.*\)/\2:\1/' test1
second:first
two:one

  The important thing to remember is: if the line matches the address, the entire line is deleted, not just the  portion of the line that is matched. 


  The append and insert commands can be applied only to a single line address, not a range of lines. The change command, however, can address a range of lines. In this case, it replaces all addressed lines with  a single copy of the text. In other words, it deletes each line in the range but the supplied text is output only once.

     $ sed -e '/^From /,/^$/c\<Mail Header Removed>' XXmail
removes the entire mail-message header and replaces it with the line "<Mail Header Removed>."

     $ sed -e '$a\End of file' file
The $ is a line-addressing symbol that matches the last line of a file.

     $ sed -e '/^\.sp/c\.sp .5' file
This command allows us to ignore the arguments and replace them regardless of what they are.

You cannot match a character by ASCII value (nor can you match octal values) in sed.[7] Instead, you have to find a key combination in vi to produce it. Use CTRL-V to quote the character. For instance, you can match an ESC character (^[). Look at the following script:


Let's look at a script that shows how the print command might be used for debugging purposes. It is used to show what the line looked like before you made any changes.


.H1 "On Egypt"

Napoleon, pointing to the Pyramids, said to his troops:
"Soldiers, forty centuries have their eyes upon you."

The following script removes that blank line:
       /^\.H1/{
        n
        /^$/d
        }
NOTE:In a longer script, you must remember that commands occurring before the next command will not be applied to the new input line, nor will commands occuring after it be applied to the old input line.




